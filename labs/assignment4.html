<!doctype html>
<html>
<head>
<title>Computer Organization (CSC 252) Spring 2018</title>

<link href="https://fonts.googleapis.com/css?family=Lato:300,700|Roboto+Condensed" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../css/main.css">

</head>
<body>

<div class="main_container">

<div class="topbar">
  <div class="topbar_left"><a href="../index.html">CSC 252</a></div>
  <div class="topbar_left"><a href="../index.html">Home</a></div>
  <div class="topbar_left"><a href="../schedule.html">Schedule</a></div>
  <div class="topbar_left"><a href="../syllabus.html">Syllabus</a></div>
  <div class="topbar_left"><a href="https://learn.rochester.edu/">Blackboard</a></div>
</div>


<div class="content_container">
<div class="home_container">
  <div class="sub_title">Assignment 4: Tuning Performance</div>

  <h2><p>
  <font color="red">If you want to use slip days you have to tell us beforehand. We won't assume slip days for late submissions.</font>
  </p></h2>

  <!--<h2>Update</h2>
  <p>
  <font color="red">If you downloaded/copied the handout tarball before 12:00PM, 3/27, please download/copy it again as we have updated it. The only change we made is to the <code>config.h</code> file. This fixes the "bug" where the speedups of naive implementations are above 1.0. Or you could simply replace the <code>config.h</code> file with <a href="https://www.cs.rochester.edu/courses/252/spring2018/labs/config.h">this one</a>.</font>
  </p>-->
  
  <h2>Introduction</h2>
  <p>
  This assignment deals with optimizing memory intensive code.&nbsp; Image
  processing offers many examples of functions that can benefit from
  optimization.&nbsp; In this lab, we will consider two image processing
  operations:&nbsp; <em>rotate</em>, which rotates an image
  counter-clockwise by <code>90°</code> and <em>smooth</em>, which
  "smooths" or "blurs" an image.&nbsp;
  </p>
  <p>
  For this lab, we will consider an image to be represented as a
  two-dimensional matrix <code>M</code>, where
  <code>M<sub>i,j</sub></code> denotes the value of the
  <code>(i,j)th</code> pixel of <code>M</code>.&nbsp; Pixel values are
  triples of red, green, and blue (RGB) values.&nbsp; We will only
  consider square images.&nbsp; Let <code>N</code> denote the number of
  rows (or columns) of an image.&nbsp; Rows and columns are numbered, in
  C-style, from <code>0</code> to <code>N-1</code>.&nbsp;
  </p>
  
  <p>The <em>rotate</em> operation turns an image 90°
  counter-clockwise, by moving each element <code>M1[i][j]</code>
  into <code>M2[N-j-1][i]</code>.&nbsp; Pictorially,
  
  </p><div align="center">
  <img alt="picture of rated image" align="center" width="460" height="170" border="0" src="./A4_files/rotate.gif">
  </div>
  
  <p>
  The <em>smooth</em> operation is implemented by replacing every pixel
  value with the average of all the pixels around it (in a maximum of
  <code>3 X 3</code> window centered at that pixel).&nbsp; Consider the
  following figure:&nbsp;
  </p>
  
  <div align="center">
  <img alt="diagram of elements used in smoothing" width="508" height="209" border="0" src="./A4_files/img15.gif">
  </div>
  <br>
  
  <p>
  The values of pixels
  <code>M2[1][1]</code> and <code>M2[N-1][N-1]</code> are given below:&nbsp;
  </p>
  
  <div align="center">
  <img width="228" height="48" border="0" src="./A4_files/img12.gif" alt="Value of pixel M2[1][1]">
  </div>
  <br><br>
  
  <div align="center">
  <img width="336" height="49" border="0" src="./A4_files/img13.gif" alt="Value of pixel M2[N-1][N-1]">
  </div>
  
  <h2>Logistics</h2>
  <p>
  You may work in a group of up to two people in solving the problems for
  this assignment.&nbsp; The only "hand-in" will be
  electronic.&nbsp; Any clarifications and revisions to the assignment
  will be posted to <a href="http://my.rochester.edu/">Blackboard</a>.&nbsp;
  </p>
  
  <h2>DUE DATES:</h2>
  <p> For the "trivia" assignment:&nbsp; 12:00pm, Thursday, March
  22.&nbsp;<br>
  For the main assignment:&nbsp; 11:59pm, Monday, April 2.&nbsp;</p>

  <h2>Hand Out Instructions</h2>
  <p>
  Start by copying <code>/u/cs252/labs18/perflab/perflab-handout.tar</code> to a
  protected directory in which you plan to do your work.&nbsp;
  (You can also download a copy <a href="https://www.cs.rochester.edu/courses/252/spring2018/labs/perflab-handout.tar">HERE</a>.)&nbsp;
  Then give
  the command:&nbsp; <code>tar xvf perflab-handout.tar</code>.&nbsp; This
  will cause a number of files to be unpacked into the directory.&nbsp;
  The only file you will be modifying and handing in is
  <code>kernels.c</code>.&nbsp; The <code>driver.c</code> program is a
  driver program that allows you to evaluate the performance of your
  solutions.&nbsp; Use the command <code>make driver</code> to generate
  the driver code and run it with the command <code>./driver</code>.&nbsp;
  </p>

  <p>
  Looking at the file <code>kernels.c</code> you'll notice a C
  structure <code>team</code> into which you should insert the requested
  identifying information about the one or two individuals comprising your
  programming team.&nbsp; <strong>Do this right away so you don't
  forget.&nbsp; Use your login ids and email adresses for your CS
  accounts.&nbsp;</strong>
  </p>
  
  <p>
  Team name in the struct is of the form "ID" where
  "ID" is your CS account login name, if you are working
  alone, or "ID1+ID2", where "ID1" is the CS login
  name of the first team member and "ID2" is the CS login name
  of the second team member.&nbsp;
  </p>
  
  <h2>Implementation Overview</h2>
  <h3>Data Structures</h3>
  The core data structure deals with image representation.&nbsp; A pixel
  is a struct as shown below:&nbsp;
  <pre>typedef struct {
      unsigned short red;   /* R value */
      unsigned short green; /* G value */
      unsigned short blue;  /* B value */
  } pixel;
  </pre>
  As can be seen, RGB values have 16-bit representations.&nbsp; An image
  <code>I</code> is represented as a one dimensional array of pixels,
  where the <code>(i,j)</code>th pixel is
  <code>I[RIDX(i,j,N)]</code>.&nbsp; Here <code>N</code> is the width
  (height) of the image matrix, and <code>RIDX</code> is a macro defined
  as follows:&nbsp;
  <pre>#define RIDX(i,j,N) ((i)*(N)+(j))
  </pre>
  See the file <code>defs.h</code> for this code.&nbsp;
  
  <h3>Rotate</h3>
  The following C function computes the result of rotating the source
  image src by <code>90°</code> and stores the result in destination
  image <code>dst</code>.&nbsp; <code>N</code> is the width (height) of
  the image.&nbsp;
  <pre>void naive_rotate(int N, pixel *src, pixel *dst) {
      int i, j;
      for(i=0; i &lt; N; i++)
          for(j=0; j &lt; N; j++)
              dst[RIDX(N-1-j,i,N)] = src[RIDX(i,j,N)];
      return;
  }
  </pre>
  The above code scans the rows of the source image matrix, copying to the
  columns of the destination image matrix.&nbsp; Your task is to rewrite
  this code to make it run as fast as possible using techniques like code
  motion, loop unrolling and blocking.&nbsp;
  
  <p>See the file <code>kernels.c</code> for this code.&nbsp;</p>
  
  <h3>Smooth</h3>
  <p>
  The smoothing function takes as input a source image src and returns the
  smoothed result in the destination image <code>dst</code>.&nbsp; Here is
  part of an implementation:&nbsp;
  </p><pre>void naive_smooth(int N, pixel *src, pixel *dst) {
      int i, j;
      for(i=0; i &lt; N; i++)
          for(j=0; j &lt; N; j++)
              dst[RIDX(i,j,N)] = avg(N, i, j, src); /* Smooth the (i,j)th pixel */
      return;
  }
  </pre>
  The function <code>avg</code> returns the average of all the pixels
  around the <code>(i,j)</code>th pixel.&nbsp; Your task is to optimize
  <code>smooth</code> (and <code>avg</code>) to run as fast as
  possible.&nbsp; (Note:&nbsp; The function <code>avg</code> is a local
  function and you can get rid of it altogether to implement
  <em>smooth</em> in some other way.)&nbsp;
  <p></p>
  
  <p>This code (and an implementation of <code>avg</code>) is in the file
  <code>kernels.c</code>.&nbsp;</p>
  
  <h3>Performance measures</h3>
  <p>
  Our main performance measure is <em>CPE</em> or <em>Cycles per
  Element</em>.&nbsp; If a function takes <code>C</code> cycles to run for
  an image of size <code>N X N</code>, the CPE value is
  <code>C/N<sup>2</sup></code>.&nbsp; Table 1 summarizes the performance
  of the naive implementations shown above and compares it against an
  optimized implementation.&nbsp; Performance is shown for for 5
  different values of <code>N</code>.&nbsp; All measurements were made on
  cycle2.csug.rochester.edu.&nbsp; As you know from the last project, these results may
  be very different on different machines.&nbsp; Your code will be tested and graded on
  cycle2 so you should keep this in mind as you program.&nbsp; <b>Note in
  particular that the reference baseline CPEs listed are specific to
  cycle2</b>.&nbsp;
  </p>
  
  <p>
  The ratios (speedups) of the optimized implementation over the naive one
  will constitute a <em>score</em> of your implementation.&nbsp; To
  summarize the overall effect over different values of <code>N</code>, we
  will compute the <em>geometric mean</em> of the results for these 5
  values.&nbsp; That is, if the measured speedups for <code>N =
  {32,64,128,256,512}</code> are <code>R<sub>32</sub></code>,
  <code>R<sub>64</sub></code>, <code>R<sub>128</sub></code>,
  <code>R<sub>256</sub></code> and <code>R<sub>512</sub></code> then we
  compute the overall performance as
  </p>
  
  <div align="center">
  <img width="319" height="32" border="0" src="./A4_files/img25.gif" alt="\begin{eqnarray*} R &amp; = &amp; \sqrt[5]{R_{32} \times R_{64} \times R_{128} \times R_{256} \times R_{512}}\end{eqnarray*}">
  </div>
  <br><br>
  
  <table align="center">
  <caption>uPEs and Ratios for Optimized vs. Naive Implementations</caption>
  <tbody><tr><td>
  <table cellpadding="3" border="1" align="center">
  <tbody><tr>
   <td align="right" colspan="2">Test case</td>
   <td align="right">1</td><td align="right">2</td><td align="right">3</td>
   <td align="right">4</td><td align="right">5</td><td align="right">&nbsp;</td>
  </tr>
  <tr>
   <td align="left">Method</td>
   <td align="left">N</td>
   <td align="right">64</td>
   <td align="right">128</td>
   <td align="right">256</td>
   <td align="right">512</td>
   <td align="right">1024</td>
   <td align="right">Geom. Mean</td>
  </tr>
  <tr>
   <td align="left">Naive <code>rotate</code> (CPE)</td>
   <td align="left">&nbsp;</td><td align="right">3.3</td> <td align="right">4.8</td>
   <td align="right">7.0</td> <td align="right">11.8</td><td align="right">14.4</td>
   <td align="right">&nbsp;</td>
  </tr>
  <tr>
   <td align="left">Optimized <code>rotate</code> (CPE)</td>
   <td align="left">&nbsp;</td><td align="right">3.0</td> <td align="right">3.1</td>
   <td align="right">3.2</td> <td align="right">4.0</td><td align="right">4.7</td>
   <td align="right">&nbsp;</td>
  </tr>
  <tr>
   <td align="left">Speedup (naive/opt)</td>
   <td align="left">&nbsp;</td><td align="right">1.1</td><td align="right">1.5</td>
   <td align="right">2.2</td>  <td align="right">2.9</td><td align="right">3.1</td>
   <td align="right">2.0</td>
  </tr>
  <tr>
   <td align="left">Method</td>
   <td align="left">N</td>
   <td align="right">32</td>
   <td align="right">64</td>
   <td align="right">128</td>
   <td align="right">256</td>
   <td align="right">512</td>
   <td align="right">Geom. Mean</td>
  </tr>
  <tr>
   <td align="left">Naive <code>smooth</code> (CPE)</td>
   <td align="left">&nbsp;</td><td align="right">76.2</td><td align="right">77.2</td>
   <td align="right">77.4</td><td align="right">77.6</td><td align="right">77.7</td>
   <td align="right">&nbsp;</td>
  </tr>
  <tr>
   <td align="left">Optimized <code>smooth</code> (CPE)</td>
   <td align="left">&nbsp;</td><td align="right">25.1</td><td align="right">27.0</td>
   <td align="right">27.3</td> <td align="right">27.5</td><td align="right">27.6</td>
   <td align="right">&nbsp;</td>
  </tr>
  <tr>
   <td align="left">Speedup (naive/opt)</td>
   <td align="left">&nbsp;</td><td align="right">3.0</td><td align="right">2.9</td>
   <td align="right">2.8</td> <td align="right">2.8</td><td align="right">2.8</td>
   <td align="right">2.9</td>
  </tr>
  </tbody></table>
  </td></tr>
  </tbody></table>
  
  <h3>Assumptions</h3>
  <p>
  To make life easier, you may assume that <code>N</code> is a multiple of
  32.&nbsp; Your code must run correctly for all such values of
  <code>N</code>, but we will measure its performance only for the 5
  values shown in Table 1.&nbsp;
  </p>
  
  <h2>Infrastructure</h2>
  <p>
  We have provided support code to help you test the correctness of your
  implementations and measure their performance.&nbsp; This section
  describes how to use this infrastructure.&nbsp; The exact details of
  each part of the assignment are described in the following
  section.&nbsp;
  <br><br>
  <strong>Note:</strong>&nbsp; The only source file you will be modifying is
  <code>kernels.c</code>.&nbsp;
  </p>
  
  <h3>Versioning</h3>
  <p>
  You will be writing many versions of the rotate and smooth
  routines.&nbsp; To help you compare the performance of all the different
  versions you’ve written, we provide a way of
  “registering” functions.&nbsp;
  </p>
  
  <p>For example, the file <code>kernels.c</code> that we have provided
  you contains the following function:&nbsp;</p>
  
  <pre>void register_rotate_functions() {
      add_rotate_function(&amp;rotate, rotate_descr);
  }
  </pre>
  
  <p>
  This function contains one or more calls to
  <code>add_rotate_function</code>.&nbsp; In the above example,
  <code>add_rotate_function</code> registers the function
  <code>rotate</code> along with a string <code>rotate_descr</code> which
  is an ASCII description of what the function does.&nbsp; See the file
  <code>kernels.c</code> to see how to create the string
  descriptions.&nbsp; This string can be at most 256 characters
  long.&nbsp;
  </p>
  
  <p>A similar function for your smooth kernels is provided in the file
  <code>kernels.c</code>.&nbsp;</p>
  
  <h3>Driver</h3>
  <p>
  The source code you will write will be linked with object code that we
  supply into a "driver" binary.&nbsp; To create this binary,
  you will need to execute the command
  </p><pre>unix&gt; make driver
  </pre>
  You will need to re-make driver each time you change the code in
  <code>kernels.c</code>.&nbsp; To test your implementations, you
  can then run the command:&nbsp;
  <pre>unix&gt; ./driver
  </pre>
  The driver can be run in four different modes:&nbsp;
  <ul>
  <li> Default mode, in which all versions of your implementation are run.&nbsp; </li>
  <li> Autograder mode, in which only the <code>rotate()</code> and
  <code>smooth()</code> functions are run.&nbsp; This is the mode we will
  run in when we use the driver to grade your hand-in.&nbsp;</li> <li>
  File mode, in which only versions that are mentioned in an input file
  are run.&nbsp;</li> <li> Dump mode, in which a one-line description of
  each version is dumped to a text file.&nbsp; You can then edit this
  text file to keep only those versions that you'd like to test
  using the file mode.&nbsp; You can specify whether to quit after
  dumping the file or to run your implementations.&nbsp;
  </li>
  </ul>
  <p></p>
  
  <p>
  If run without any arguments, <code>driver</code> will run all of your
  versions
  (default mode).&nbsp; Other modes and options can be specified by
  command-line arguments to <code>driver</code>, as listed below:&nbsp;
  </p>
  
  <p>
  <code>-g</code> :&nbsp; Run only <code>rotate()</code> and
  <code>smooth()</code> functions (autograder mode).&nbsp;
  </p>
  
  <p>
  <code>-f &lt;funcfile&gt;</code> :&nbsp; Execute only those versions
  specified in <code>&lt;funcfile&gt;</code> (file mode).&nbsp;
  </p>
  
  <p>
  <code>-d &lt;dumpfile&gt;</code> :&nbsp; Dump the names of all versions
  to a dump file called <code>&lt;dumpfile&gt;</code>, one line to a
  version (dump mode).&nbsp;
  </p>
  
  <p>
  <code>-q</code> :&nbsp; Quit after dumping version names to a dump
  file.&nbsp; To be used in tandem with <code>-d</code>.&nbsp; For
  example, to quit immediately after printing the dump file, type
  <code>./driver -qd dumpfile</code>.&nbsp;
  </p>
  
  <p>
  <code>-h</code> :&nbsp; Print the command line usage.&nbsp;
  </p>
  
  <h3>Team Information</h3>
  <p>
  Important:&nbsp; Before you start, you should fill in the struct in
  <code>kernels.c</code> with information about your team (group
  name, team member names and email addresses).&nbsp; This struct is
  just like the one for the Data Lab (assignment 1).&nbsp;
  </p>
  
  <h2>Assignment Details</h2>
  <h3>Optimizing Rotate (50 points)</h3>
  <p>
  In this part, you will optimize <code>rotate</code> to achieve as low a
  CPE as possible.&nbsp; You should compile <code>driver</code> and then
  run it with the appropriate arguments to test your
  implementations.&nbsp; For example, running <code>driver</code> with the
  supplied naive version (for <code>rotate</code>) generates the output
  shown below:&nbsp;
  </p>
  
  <pre>unix&gt; ./driver
  Teamname: ta
  Member 1: ta
  Email 1: ta's email address
  
  Rotate: Version = naive_rotate: Naive baseline implementation:
  Dim             64      128     256     512     1024    Mean
  Your CPEs       3.3     4.8     7.3     11.9    14.3
  Baseline CPEs   3.3     4.8     7.0     11.8    14.4
  Speedup         1.0     1.0     1.0     1.0     1.0     1.0
  
  </pre>
  
  <h3>Optimizing Smooth (50 points)</h3>
  <p>
  In this part, you will optimize smooth to achieve as low a CPE as
  possible.&nbsp;
  </p>
  
  <p>For example, running <code>driver</code> with the supplied naive
  version (for <code>smooth</code>) generates the output shown
  below:&nbsp;</p>
  
  <pre>unix&gt; ./driver
  Teamname: ta
  Member 1: ta
  Email 1: ta's email address
  
  Smooth: Version = naive_smooth: Naive baseline implementation:
  Dim             32      64      128     256     512     Mean
  Your CPEs       76.4    77.2    77.4    77.5    77.7
  Baseline CPEs   76.2    77.2    77.4    77.6    77.7
  Speedup         1.0     1.0     1.0     1.0     1.0     1.0
  
  </pre>
  
  <p>
  <strong>Some advice:</strong>&nbsp; Look at the assembly code generated
  for <code>rotate</code> and <code>smooth</code>.&nbsp; Focus on
  optimizing the inner loop (the code that gets repeatedly executed in a
  loop) using the optimization tricks covered in class and in chapters 5
  and 6 of the text.&nbsp;  (Note: if you didn't read chapter 5
  carefully before the midterm, you'll want to read it now.&nbsp; You
  won't do well on this assignment without it.)&nbsp;
  The <code>smooth</code> function is more
  compute-intensive and less memory-sensitive than the <code>rotate</code>
  function, so the optimizations are of somewhat different flavors.&nbsp;
  You may want to consult the authors' "Web Aside" on
  <a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">using
  blocking to increase temporal locality</a>.&nbsp;
  
  </p><h3>Coding Rules</h3>
  <p>
  You may write any code you want, as long as it satisfies the following
  requirements:&nbsp;
  </p><ul>
  <li> It must be in ANSI C.&nbsp; You may not use any embedded assembly
  language statements.&nbsp;</li>
  <li> It must not interfere with the time measurement mechanism.&nbsp;
  You will also be penalized if your code prints any extraneous
  information.&nbsp;</li>
  </ul>
  You can only modify code in <code>kernels.c</code>.&nbsp; You are
  allowed to define macros, additional global variables, and other
  procedures in this file.&nbsp;
  <p></p>
  
  <h3>Evaluation</h3>
  <p>
  Your solutions for <code>rotate</code> and <code>smooth</code> will each
  count for 50% of your grade.&nbsp; The score for each will be based on
  the following:&nbsp;
  </p><ul>
  <li>
  Correctness:&nbsp; You will get NO CREDIT for buggy code that causes
  the driver to complain!&nbsp; This includes code that correctly operates
  on the test sizes, but incorrectly on image matrices of other
  sizes.&nbsp; As mentioned earlier, you may assume that the image
  width (height) is a multiple of 32.&nbsp;
  </li>
  <li>
  CPE:&nbsp; You will get full credit for your implementations of
  <code>rotate</code> and <code>smooth</code> if they are correct and
  achieve mean CPE speedups above thresholds <code>1.5</code> and
  <code>2.0</code> respectively.&nbsp; We will award up to 10 points
  extra credit for each function if you match or beat the performance of
  the optimized version described above.&nbsp; You will get partial credit
  for a correct implementation that does better than the supplied naive
  one.&nbsp;
  </li>
  </ul>
  <p></p>
  
  <h2>"Trivia" Assignment </h2>
  <p>Trivia assignment is available on Blackboard as a test. Below is the exact same four questions, just for reference purposes.</p>

  <ol>
  <li>List your team name and the full name and email address of each team
  member.&nbsp;</li>
  <li>Fill your team name and member information into the team structure,
  and make and run the driver.&nbsp; What output do you get?&nbsp;</li>
  <li>Review section 5.8 in the textbook, then analyze <code>foo()</code> and
  <code>bar()</code> below.&nbsp; Do they do
  the same thing?&nbsp; If not, why not?&nbsp; If so, which would you
  expect to be faster and why?&nbsp; (Assume that arrays a[100] and b[100]
  are initialized globals.)&nbsp;
  <pre>
  void foo() {
      int i;
      for (i = 0; i &lt; 100; i++){
          a[i] = a[i] + b[i];
      }
  }
    
  void bar() {
      int i = 0;
      while (i &lt; 100){
          a[i] += b[i++];
          a[i] += b[i++];
          a[i] += b[i++];
          a[i] += b[i++];
      }
  }
  </pre>
  </li>
  <li>How might the topic in section 5.5 of the textbook be used to improve
      the functionality of <code>naive_smooth</code>?&nbsp;</li>
  </ol>
  <p></p>
  
  <h2>Turn In Instructions</h2>
  <p>
  When you have completed the lab, you will hand in one file,
  <code>kernels.c</code>, that contains your solution.&nbsp; Here is how
  to hand in your solution:&nbsp;
  </p><ul>
  <li>
  Make sure you have included your identifying information in
  the team struct in kernels.c.&nbsp;
  </li>
  <li>
  Make sure that the <code>rotate()</code> and <code>smooth()</code> functions
  correspond
  to your fastest implementations, as these are the only functions
  that will be tested when we use the driver to grade your assignement.&nbsp;
  </li>
  <li>
  Remove any extraneous print statements.&nbsp;
  </li>
  <li>
  Place your <code>kernels.c</code> file in a directory by itself, go into that
  directory, and type:&nbsp;
  <pre>/u/cs252/bin/TURN_IN .</pre>
  It will ask you for your partner's netid. If you are working alone, simply press enter. Otherwise, put your partner's netid, and press enter.
  <b>Note that there's a dot in that command!&nbsp;</b>
  </li>
  <li>
  After the hand-in, if you discover a mistake and want to submit
  a revised copy, follow the instructions above, and your new submission will overwrite the previous one.&nbsp;
  </li>
  </ul>
  <p></p>

<hr size="1">
</div>  <!-- end of home_container -->

<div class="footer">
University of Rochester, Department of Computer Science
</div>


</div>  <!-- end of content_container (defined in header.php) -->
</div>  <!-- end main_container (defined in header.php) -->


</body>
</html>

